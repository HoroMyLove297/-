# 算法复习概要

## 陈梓睿整理、收纳

## 算法题

### 逆置单链表

#### 递归

```cpp
#include<iostream>
using namespace std;
struct Node {
	int value;
	Node* next;
};

void ReListNode(Node* tail, Node* head) {
	if (head == tail)return;
	Node* tmp = head->next;
	head->next = tail->next;
	tail->next = head;
	ReListNode(tail, tmp);
}
Node* ReList(Node* head) {
	Node* tmp = head;
	while (head->next != NULL)head = head->next;
	ReListNode(head, tmp);
	return head;
}

void PrintList(Node* head) {
	int n = 3;
	while (head != NULL) {
		cout << head->value << " ";
		head = head->next;
	}
	cout << endl;
}

int main(void) {
	int n;
	cin >> n;
	Node* a, * tmp, * tail;
	tmp = (Node*)malloc(sizeof(Node));
	tail = (Node*)malloc(sizeof(Node));
	cin >> tmp->value;
	tmp->next = NULL;
	a = tmp;
	for (int i = 0;i < n - 1;i++) {
		tail = (Node*)malloc(sizeof(Node));
		cin >> tail->value;
		tail->next = NULL;
		tmp->next = tail;
		tmp = tmp->next;
	}
	cout << "逆置前:";
	PrintList(a);
	a=ReList(a);
	cout <<"逆置后:";
	PrintList(a);

	return 0;
}

```



### 求解幸运数

#### 递归

```cpp
#include<iostream>
using namespace std;
int f(int x) {
	return x < 10 ? x : x%10+f(x / 10);
}

int g(int x) {
	return x < 2 ? x : x % 2 + g(x / 2);
}
int main(void) {
	int n;
	cin >> n;
	for (int i = 1;i <= n;i++) {
		if (f(i) == g(i)) {
			cout << i<<" ";
		}
	}
	return 0;
}

```

### 求逆序数

#### 分治法

```cpp
#include<map>
#include<iostream>
using namespace std;
int num = 0;
void GetNxNum(int a[],int l,int r) {
	if(l<r){
		int mid = (l + r) / 2;
		GetNxNum(a,l,mid);
		GetNxNum(a,mid+1,r);
		for (int i = l;i <= mid;i++) {
			for (int j = mid;j <= r;j++) {
				if (a[j] < a[i])num++;
			}
		}
	}	
}
int main(void) {
	int a[1000];
	int n;
	cin >> n;
	for (int i = 0;i < n;i++) {
		cin >> a[i];
	}
	GetNxNum(a, 0, n - 1);
	cout << num;

}

```



### 完数问题

#### 蛮力法

```cpp
```



### 01背包

#### 分支界限法

```cpp
```



### 堆砖块

#### 动态规划

```cpp
```

